package com.inyc.utils {	/**	 * @author stevewarren	 */	public class Validation {				public function Validation(){					}				static public function isNotEmpty( str: String ): Boolean		{			if(str==null) return false;						str = TextUtil.trim( str );			if( str == null || str == "" || str.length <1 )	{				trace( "is Empty false" );					return false;			}							trace( "is Empty true" );			return true;		}				static public function isValidEmail( p_email: String ): Boolean		{			var atLoc:Number = p_email.indexOf( "@" );			var lastDotLoc:Number = p_email.lastIndexOf( "." );						if ( p_email == null ) return false;						if ( p_email == "" ) return false;					//the shortest p_email address I can think of is a@a.aa which is six characters long, anything less must be invalid.			if ( p_email.length < 6 ) return false;					//Commas are invalid			if ( p_email.indexOf( "," ) != -1 ) return false;				if ( lastDotLoc == -1 ) return false;				if ( atLoc == -1 ) return false;					// there must be a ???.??? after the ???@???.			if ( lastDotLoc < atLoc ) return false;						// there is only one ???@???.			if ( p_email.lastIndexOf( "@" ) != atLoc ) return false;				// the last instance of ???.??? in the string must be followed by at least two characters. Note that because a string's index begins at zero, a string with one character would have that character indexed at the zero position. To allow for this inconsistency we add 3, not 2.			if ( ( lastDotLoc + 3 ) > p_email.length ) return false;								return true;				}				//TEST THIS BEFORE USING		//SOURCE: http://snipplr.com/view.php?codeview&id=47064		static public function isValidEmail2(email:String):Boolean			{			    var emailExpression:RegExp = /([a-z0-9._-]+?)@([a-z0-9.-]+)\.([a-z]{2,4})/i;			    return emailExpression.test(email);			}				static public function isValidBirthDate( year: Number, month: Number, day: Number ): Boolean		//static public function isValidBirthDate(vig:ValidationGroup ):Boolean		{			//var year:uint = vig.getItemAt(0).component.value;						//var month:uint = vig.getItemAt(1).component.value;						//var day:uint = vig.getItemAt(2).component.value;						var testMonth = month-1;						var bDate = new Date(year,testMonth,day);			if (bDate.getFullYear() != year) { 				return false; 			}			if (bDate.getMonth() != testMonth) { 				return false; 			}			if (bDate.getDate() != day) { 				return false; 			}						/*			var earliestBirthDate = new Date();			earliestBirthDate.setFullYear( earliestBirthDate.getFullYear()-100 );								var latestBirthDate = new Date();			latestBirthDate.setFullYear( latestBirthDate.getFullYear() );						if ( bDate.getTime() < earliestBirthDate.getTime() ) {				return false;			} else if (bDate.getTime() > latestBirthDate.getTime() ) {				return false;			}			 * 			 */						return true;			}				static public function isValidZipCode( p_zip: String ): Boolean 		{			//p_zip = TextUtil.trim( p_zip );			var valid = true;			// we are allowing the format 12345 or 12345-6789			if (p_zip == null || p_zip == "" || p_zip.length < 5 || p_zip.length > 10 )			{				valid = false;			}			else if( p_zip.length > 5 && p_zip.charAt(5) != "-" )			{				valid = false;			}			else if( p_zip.length > 5 && p_zip.charAt(5) == "-" && p_zip.length != 10 )			{				valid = false;			}						for(var i:Number=0;i<p_zip.length;i++)				{					if(isNaN(Number(p_zip.charAt(i))) && p_zip.charAt(i)!="-")					{					return false;					}				}						return valid;		}						static public function isValidUSPhone(inPhoneNum:String):Boolean {			var numbersOnly:String = "";			for(var i=0;i<inPhoneNum.length;i++){				if(!isNaN(Number(inPhoneNum.charAt(i)))) numbersOnly += inPhoneNum.charAt(i);			}			if(numbersOnly.length == 10){				return true;			} else {				return false;			}				}	}}